# What is Rxjs?

Rxjs 全称是 Reactive Extensions for JavaScript。

拆解下，关键部分是 Reactive 和 Extensions。其中：

- Reactive 指的是 Reactive Programming 响应式编程;
- Extensions 指它是一种扩展机制。

## What is Reactive Programming? 什么是响应式编程？

Reactive Programming 响应式编程是一种编程范式，或者是一种编程风格，或者是一种编程思想。不要被“响应式”这个词吓到,其实这个概念并没有那么难理解。

如果你使用过 Excel 的公式功能，你就已经应用过响应式编程。下图演示使用 Excel 来统计多个格子中数据之和的功能，在 Excel 表格中，选中 C9 这个格子，在公式部分输入`=SUM(C2:C8)`，之后，无论我在 C2 到 C8 中填写什么数字，C9 这个格子里的数值都会自动更新为 C2 到 C8 所有格子的数值之和，换句话说，C9 能够对这些格子的数值变化作出“响应”​。

<img alt="reactive-programming-excel.jpg" src="./images/reactive-programming-excel.jpg" width="300" >

在这个 Excel 表格中，输入就是用户在 C2 到 C8 格子中填充的数值，用户这个填充动作是完全不可预料的，可能先填 C2，也可能先填 C5，用户还可能反复修改 C4 格子里的数值；用户可能每天填一个数字，也可能到星期天把 7 个格子一次填完……无论用户用何种方式操作，可以把操作看作是基于时间的一个动作序列，每次的操作动作都会产生一个数据，整个操作序列连续起来，像是会产生一个数据流，这个流中的一个元素，是对某个格子修改的的数值，然后不管你是顺序修改，还是隔天修改，或者间隔修改，这个程序都一视同仁，遵循同样的方式响应给 C9。

这个例子展示了响应式编程中的核心思想，就是把程序中的数据看作是一个可以被观察的序列，也可以称为数据流，其中数据的变化会被自动传播到所有依赖它的地方。

## What is Extensions? 什么是扩展机制？

目前社区中的各种编程语言，比如 `.Net / Java / C++ / Ruby / Python / JavaScript` 等等，并没有天生支持响应式编程，所以需要为这些语言增加一些功能扩展（Extension）来支持响应式编程。

Reactive Extensions 简称 Rx ，最初由微软公司实现并开源，也就是 Rx.NET，因为 Rx 带来的编程方式大大改进了异步编程模型，在.NET 之后，众多开发者在其他平台和语言上也实现了 Rx 的类库。可见，Rx 其实是一个大家族，在这个大家族中，还有用 Java 实现的 RxJava，用 C++实现的 RxCpp，用 Ruby 实现的 Rx.rb，用 Python 实现的 RxPy。包括这里介绍的 RxJS，就是 JavaScript 语言实现响应式编程的功能扩展库。

## 延伸概念

### 什么是函数式编程？

顾名思义，函数式编程就是非常强调使用函数来解决问题的一种编程方式。在 Rxjs 中，函数式编程是 Rxjs 的核心思想之一。

函数式编程的主要特点：

- 声明式 Declaration: 函数式编程的代码通常是声明式的，即代码描述了要做什么，而不是如何去做。
- 纯函数 Pure Function: 函数式编程中的函数是纯函数，即函数的返回值只依赖于函数的参数，不依赖于任何外部状态。
- 无副作用 No Side Effects: 函数式编程中的函数不能产生任何副作用，即函数不能修改外部状态，也不能调用任何可能产生副作用的函数。
- 不可变性 Immutability: 函数式编程中的数据是不可变的，即一旦创建就不会被修改。

> JavaScript 语言中函数有一等公民的特性，指的是函数可以作为参数传递给其他函数，也可以作为返回值返回。

#### 声明式 Declaration

和声明式相对应的编程方式叫做命令式编程（ImperativeProgramming）​，它用代码描述应该如何去做，而不是告诉应该做什么。

```js
function double(arr) {
  // 步骤1：创建一个新数组，用于存储结果
  const result = []
  // 步骤2：遍历数组，将每个元素乘以2，并将结果添加到新数组中
  for (let i = 0; i < arr.length; i++) {
    result.push(arr[i] * 2)
  }
  // 步骤3：返回新数组
  return result
}

function addOne(arr) {
  const result = []
  for (let i = 0; i < arr.length; i++) {
    result.push(arr[i] + 1)
  }
  return result
}
```

如果比较一下 double 和 addOne 这两个函数的代码，就会发现，除了函数名和 push 的参数之外，这两个函数如出一辙，简直就是一个模子里倒出来的。实际上，我在写 addOne 的时候，就是把 double 的代码拷贝过来，把函数名改为 addOne，然后把 push 的参数改为 arr[i]+1。
这种代码的问题在于，它的可读性很差，而且容易出错。如果我需要对数组中的每个元素执行其他操作，比如乘以 3、除以 2、取平方根等等，我就需要写很多类似的函数，这会导致代码重复，而且维护起来也很麻烦。

> 重复代码可能是所有软件中邪恶的根源

现在用函数式编程来重写上面的代码：

```js
function double(arr) {
  return arr.map((item) => item * 2)
}
function addOne(arr) {
  return arr.map((item) => item + 1)
}

// 如果用箭头函数来重写
const double = (arr) => arr.map((item) => item * 2)
const addOne = (arr) => arr.map((item) => item + 1)
```

现在，这两个函数的代码就非常简洁明了了，它们的功能是一样的，都是对数组中的每个元素执行相同的操作。
这种代码的优点在于，它的可读性很好，而且容易维护。如果我需要对数组中的每个元素执行其他操作，比如乘以 3、除以 2、取平方根等等，我只需要修改 map 函数的参数即可。

也就是说只需要告诉我你要做什么的函数作为入参就可以了，由程序封装了怎么去做的逻辑。声明式编程抽象了代码的细节，可以认为声明式编程解决了命令式编程重复代码的问题。

#### 纯函数 Pure Function

所谓纯函数，指的是满足下面两个条件的函数。

- 函数的执行过程完全由输入参数决定，不会受除参数之外的任何数据影响。
- 函数不会修改任何外部状态，比如修改全局变量或传入的参数对象。

所以可以认为纯函数做的事情就是输入参数到返回结果的一个映射，不会产生副作用（Side Effect）​。与之相对的就是“不纯函数”​（Impure Function）​，一个函数之所以不纯，可能做了下面这些事情：

- 改变全局变量的值。
- 改变输入参数引用的对象
- 读取了外部状态，或者网络输入等。
- 抛出了异常

纯函数是(Pure Function)通常也是无副作用的 (No Side Effects)。

#### 不可变性 Immutability

不可变性 Immutability 是指数据一旦创建就不能被修改，任何修改都会返回一个新的对象。

对于刚刚接触这个概念时候，可能会觉得莫名其妙，因为程序就是用代码指令在操作数据，如果数据不能变化，那一个程序又能够干什么有用的事情？

程序要好发挥作用当然是要产生变化的数据，但是并不意味着必须要去修改现有数据，更好的方法是通过产生新的数据，来实现这种“变化”​，也就是说，当我们需要数据状态发生改变时，保持原有数据不变，产生一个新的数据来体现这种变化。

不可改变的数据就是 Immutable 数据，它一旦产生，我们就可以肯定它的值永远不会变，这非常有利于代码的理解。

在 JavaScript 语言中，字符串类型、数字类型就是不可改变的数据。使用这两种类型的数据给你带来的麻烦比较少。相反，JavaScript 中大部分对象都是可变的，比如数组 array 的 push、pop、sort 方法都会改变一个数组的原有的内容，所以在最新的 Js 规范中引入了不可变性的方法 with、toSorted、toSpliced 等方法。

```js
const arr = [1, 2, 3]
arr.push(4)
console.log(arr) // [1, 2, 3, 4]

const newArr = arr.with(1, 5) // 方法是返回一个新的数组，不会改变原有的数组
console.log(newArr) // [1, 5, 3]
console.log(arr) // [1, 2, 3]
```

另外，要注意 JavaScript 中的 const 关键字虽然有常数（constant）的意思，但其实只是规定一个变量引用对象的地址不能改变，却没有规定这个 const 变量引用的对象自身不能发生改变，所以，这个“常量”依然是变量。

```js
const a = "immutable"
a = "mutable" // 报错，因为 a 是一个常量，不能重新赋值
const b = [1, 2, 3] // b 实际赋值的是一个数组的引用地址，这个引用地址不能改变，但是数组本身是可变的
b.push(4) // 不会报错
const obj = {
  // obj 实际赋值的是一个对象的引用地址，这个引用地址不能改变，但是对象本身是可变的
  name: "immutable",
  age: 18,
}
obj.name = "mutable"
obj.age = 20
obj = {
  name: "mutable",
  age: 20,
}
```

### 什么是面向对象编程

通过与函数式编程作为对比的是面向对象编程。面向对象编程是一种编程范式，它将程序中的数据看作是一个对象，对象有属性和方法。对象的属性和方法可以被其他对象访问和修改。

- 面向对象编程三大特征：封装、继承、多态。
- 函数式编程三大特征：声明式、纯函数、不可变性。

为了避免命令式编程中数据的随意修改容易产生问题，面向对象的思想是把数据封装在类的实例对象中，把数据藏起来，让外部不能直接操作这些对象，只能通过类自身提供的实例方法来读取和修改这些数据，这样就限制了对数据的访问方式。而函数式编程则是尽量减少不去改变数量，通过创建新数据，来减少问题。

> 面向对象是把数据变化封装在内部，函数式编程是不去改变原数据，以减少不确定性带来程序的影响。
